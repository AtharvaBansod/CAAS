{
  "feature_group": "sdk-realtime",
  "description": "Socket.IO integration for real-time features",
  "tasks": [
    {
      "task-name": "Socket.IO Client Integration",
      "feature-details": "Implement Socket.IO client wrapper for real-time communication. Handle connection management, automatic reconnection, room subscriptions, and event handling. Integrate with CAASClient event emitter.",
      "feature-dependency": ["SDK-002"],
      "ai-prompt": "Create SocketClient in packages/sdk/src/realtime/socket-client.ts:\n\n1. Constructor accepts SocketClientOptions:\n   - serverUrl: string\n   - apiKey: string\n   - appId: string\n   - autoReconnect?: boolean (default true)\n   - reconnectAttempts?: number (default 5)\n   - reconnectDelay?: number (default 1000)\n   - debug?: boolean\n\n2. Connection Methods:\n   - connect(): Promise<void>\n     - Authenticate with apiKey and appId via auth option\n     - Wait for 'connect' event before resolving\n     - Handle authentication errors\n   - disconnect(): void\n   - isConnected(): boolean\n\n3. Room Management:\n   - joinConversation(conversationId: string): Promise<void>\n   - leaveConversation(conversationId: string): Promise<void>\n   - joinedConversations: Set<string> (readonly)\n\n4. Event Handling:\n   - Internal event listeners for all server events:\n     - 'message:new' -> emit 'message'\n     - 'message:updated' -> emit 'message:updated'\n     - 'message:deleted' -> emit 'message:deleted'\n     - 'conversation:created' -> emit 'conversation:created'\n     - 'conversation:updated' -> emit 'conversation:updated'\n     - 'presence:changed' -> emit 'presence'\n     - 'typing:start' -> emit 'typing'\n     - 'typing:stop' -> emit 'typing'\n   - Emit events through passed EventEmitter\n\n5. Typing Indicators:\n   - startTyping(conversationId: string): void\n   - stopTyping(conversationId: string): void\n   - Internal debounce to prevent spam\n\n6. Connection Events:\n   - Handle 'connect', 'disconnect', 'connect_error', 'reconnect', 'reconnect_failed'\n   - Emit connection status changes through EventEmitter\n   - Rejoin conversations after reconnect\n\n7. Socket.IO options:\n   - transports: ['websocket', 'polling']\n   - path: '/socket.io'\n   - withCredentials: true\n\nImport socket.io-client as peer dependency.",
      "testing-instructions": "1. Mock socket.io-client and test connection flow\n2. Test authentication sends correct credentials\n3. Test room join/leave emits correct events\n4. Test automatic reconnection attempts\n5. Test rooms are rejoined after reconnect\n6. Test typing indicator debounce (only sends after 2s idle)\n7. Test disconnect clears all state\n8. Test connection errors are properly propagated",
      "acceptance_criteria": [
        "Socket connection authenticates with API key",
        "Room management (join/leave) works correctly",
        "All server events are mapped to client events",
        "Automatic reconnection with exponential backoff",
        "Rooms are rejoined after reconnect",
        "Typing indicators are debounced",
        "Connection status is accurately tracked",
        "Debug mode logs socket events"
      ],
      "files_to_create": [
        "packages/sdk/src/realtime/socket-client.ts",
        "packages/sdk/src/realtime/events.ts",
        "packages/sdk/src/realtime/types.ts"
      ],
      "docker_requirements": null,
      "task_id": "SDK-007"
    },
    {
      "task-name": "Presence Manager",
      "feature-details": "Implement presence tracking functionality for the SDK. Track current user's presence state, subscribe to other users' presence updates, and provide hooks for presence changes. Integrate with Socket.IO for real-time updates.",
      "feature-dependency": ["SDK-007"],
      "ai-prompt": "Create PresenceManager in packages/sdk/src/realtime/presence.ts:\n\n1. Constructor accepts:\n   - socketClient: SocketClient\n   - eventEmitter: EventEmitter\n   - usersClient: UsersClient\n\n2. Properties:\n   - currentStatus: PresenceStatus (readonly)\n   - subscribedUsers: Map<string, PresenceStatus> (readonly)\n\n3. Methods:\n   - setStatus(status: PresenceStatus): Promise<void>\n     Status: 'online' | 'away' | 'busy' | 'offline'\n     Emits to socket and updates via REST API\n\n   - subscribe(userIds: string[]): void\n     Subscribe to presence updates for users\n     Fetches initial presence via REST then listens for updates\n\n   - unsubscribe(userIds: string[]): void\n     Stop watching users' presence\n\n   - getPresence(userId: string): PresenceStatus | undefined\n     Get cached presence for a user\n\n   - getBulkPresence(userIds: string[]): Promise<Map<string, PresenceStatus>>\n     Fetch presence for multiple users (REST + cache)\n\n4. Auto-presence:\n   - setAutoPresence(enabled: boolean): void\n     When enabled:\n     - Set 'online' on connect\n     - Set 'away' after 5 minutes of inactivity (browser only)\n     - Set 'offline' on disconnect\n     - Listen to visibility change for tab focus\n\n5. Event Handling:\n   - Listen to 'presence:changed' from socket\n   - Update internal cache\n   - Emit 'presence' event with { userId, status, lastSeen }\n\n6. Cleanup:\n   - destroy(): void\n     Remove all listeners, clear cache\n\nImplement activity detection using mouse/keyboard events in browser.",
      "testing-instructions": "1. Test setStatus() updates via both socket and REST\n2. Test subscribe() fetches initial presence\n3. Test presence updates are cached correctly\n4. Test auto-presence sets online on connect\n5. Test auto-away after inactivity timeout\n6. Test visibility change detection (mock document.hidden)\n7. Test unsubscribe stops receiving updates\n8. Test destroy() cleans up all listeners",
      "acceptance_criteria": [
        "Current user can set their presence status",
        "Can subscribe to other users' presence",
        "Presence updates are received in real-time",
        "Cache is maintained for quick lookups",
        "Auto-presence correctly detects activity",
        "Tab visibility changes update presence",
        "Bulk presence fetch batches requests",
        "Cleanup properly removes all listeners"
      ],
      "files_to_create": [
        "packages/sdk/src/realtime/presence.ts"
      ],
      "docker_requirements": null,
      "task_id": "SDK-008"
    },
    {
      "task-name": "Message Sync and Offline Support",
      "feature-details": "Implement message synchronization for handling missed messages during disconnection. Queue outgoing messages when offline and sync when reconnected. Maintain local message cache for optimistic updates.",
      "feature-dependency": ["SDK-007", "SDK-004"],
      "ai-prompt": "Create MessageSync in packages/sdk/src/realtime/message-sync.ts:\n\n1. Constructor accepts:\n   - socketClient: SocketClient\n   - messagesClient: MessagesClient\n   - eventEmitter: EventEmitter\n\n2. Sync on Reconnect:\n   - Track lastMessageId for each conversation\n   - On reconnect, fetch messages after lastMessageId\n   - Emit 'message' events for missed messages\n   - Update lastMessageId tracking\n\n3. Offline Queue:\n   - queue: PendingMessage[] (messages to send when online)\n   - queueMessage(message: SendMessageOptions): string\n     Returns clientId for tracking\n   - processQueue(): Promise<void>\n     Send all queued messages on reconnect\n   - getQueuedMessages(): PendingMessage[]\n   - removeFromQueue(clientId: string): void\n\n4. Optimistic Updates:\n   - pendingMessages: Map<string, OptimisticMessage>\n   - When message is queued, emit 'message' with pending: true\n   - When message is confirmed, emit 'message:confirmed' with serverId\n   - When message fails, emit 'message:failed' with error\n\n5. Message Cache:\n   - cache: Map<conversationId, Message[]>\n   - setCache(conversationId: string, messages: Message[]): void\n   - getCache(conversationId: string): Message[] | undefined\n   - updateCache(message: Message): void\n   - clearCache(conversationId?: string): void\n\n6. Storage (optional):\n   - Persist queue to localStorage in browser\n   - Restore queue on init\n   - Configurable via options\n\n7. Methods:\n   - enable(): void\n   - disable(): void\n   - isEnabled(): boolean\n\nHandle race conditions between sync and real-time messages.",
      "testing-instructions": "1. Test sync fetches messages after lastMessageId on reconnect\n2. Test offline queue stores messages\n3. Test queue is processed in order on reconnect\n4. Test optimistic update emits pending message immediately\n5. Test confirmation updates message with server ID\n6. Test failure emits error event\n7. Test cache is updated on new messages\n8. Test localStorage persistence (mock localStorage)\n9. Test race condition: real-time message arrives during sync",
      "acceptance_criteria": [
        "Missed messages are synced after reconnection",
        "Messages are queued when offline",
        "Queue is processed in order on reconnect",
        "Optimistic updates provide immediate feedback",
        "Failed messages emit appropriate events",
        "Cache provides quick access to messages",
        "Queue is persisted to localStorage",
        "Race conditions are handled correctly"
      ],
      "files_to_create": [
        "packages/sdk/src/realtime/message-sync.ts",
        "packages/sdk/src/realtime/offline-queue.ts",
        "packages/sdk/src/utils/storage.ts"
      ],
      "docker_requirements": null,
      "task_id": "SDK-009"
    },
    {
      "task-name": "SDK React Hooks",
      "feature-details": "Create React hooks package that wraps the SDK for easy integration with React applications. Provide hooks for messages, conversations, presence, and real-time updates. Use React Query for data fetching and caching.",
      "feature-dependency": ["SDK-001", "SDK-002", "SDK-003", "SDK-004", "SDK-005", "SDK-007"],
      "ai-prompt": "Create React hooks package at packages/sdk-react/:\n\n1. Provider:\n   - CAASProvider component that wraps children\n   - Accepts: client (CAASClient instance) or clientOptions\n   - Creates QueryClient internally if not provided\n   - Provides CAASContext with client instance\n\n2. useClient():\n   - Returns CAASClient instance from context\n   - Throws if used outside provider\n\n3. useConversations(options?: ListConversationsOptions):\n   - Returns: { conversations, isLoading, error, refetch, fetchNextPage, hasNextPage }\n   - Uses useInfiniteQuery for pagination\n   - Auto-refetch on conversation:created event\n\n4. useConversation(conversationId: string):\n   - Returns: { conversation, isLoading, error, refetch }\n   - Uses useQuery with conversationId as key\n\n5. useMessages(conversationId: string, options?: ListMessagesOptions):\n   - Returns: { messages, isLoading, error, fetchOlder, fetchNewer, hasOlder }\n   - Uses useInfiniteQuery with bidirectional pagination\n   - Auto-adds new messages from real-time events\n   - Optimistic updates for sent messages\n\n6. useSendMessage():\n   - Returns: { sendMessage, isSending, error }\n   - sendMessage(options: SendMessageOptions): Promise<Message>\n   - Optimistic update with rollback on failure\n   - Uses useMutation\n\n7. usePresence(userIds: string[]):\n   - Returns: Map<string, PresenceStatus>\n   - Subscribes to presence updates\n   - Cleanup on unmount\n\n8. useTypingIndicator(conversationId: string):\n   - Returns: { typingUsers: User[], startTyping, stopTyping }\n   - Debounces startTyping calls\n   - Auto-stops after 3 seconds\n\n9. useConnectionStatus():\n   - Returns: { isConnected, isConnecting, lastDisconnectedAt }\n\n10. useUnreadCount(conversationId?: string):\n    - Returns number of unread messages\n    - Updates in real-time\n\nUse @tanstack/react-query as peer dependency.",
      "testing-instructions": "1. Test CAASProvider initializes client correctly\n2. Test useConversations returns paginated data\n3. Test useMessages adds new messages from events\n4. Test useSendMessage optimistic update\n5. Test useSendMessage rollback on failure\n6. Test usePresence subscribes and unsubscribes\n7. Test useTypingIndicator debouncing\n8. Test useConnectionStatus updates on connect/disconnect\n9. Test all hooks throw outside provider\n10. Test cleanup on unmount",
      "acceptance_criteria": [
        "Provider correctly initializes and provides client",
        "All hooks work with proper types",
        "Infinite queries handle pagination correctly",
        "Real-time events update hook state",
        "Optimistic updates provide immediate feedback",
        "Mutations rollback on failure",
        "Presence hooks cleanup subscriptions",
        "TypeScript types are exported",
        "Package is tree-shakeable"
      ],
      "files_to_create": [
        "packages/sdk-react/package.json",
        "packages/sdk-react/tsconfig.json",
        "packages/sdk-react/src/index.ts",
        "packages/sdk-react/src/provider.tsx",
        "packages/sdk-react/src/hooks/useClient.ts",
        "packages/sdk-react/src/hooks/useConversations.ts",
        "packages/sdk-react/src/hooks/useConversation.ts",
        "packages/sdk-react/src/hooks/useMessages.ts",
        "packages/sdk-react/src/hooks/useSendMessage.ts",
        "packages/sdk-react/src/hooks/usePresence.ts",
        "packages/sdk-react/src/hooks/useTypingIndicator.ts",
        "packages/sdk-react/src/hooks/useConnectionStatus.ts",
        "packages/sdk-react/src/hooks/useUnreadCount.ts",
        "packages/sdk-react/README.md"
      ],
      "docker_requirements": null,
      "task_id": "SDK-010"
    }
  ]
}
