{
  "task_group": "analytics-service",
  "description": "Backend analytics service for data aggregation and API",
  "priority": "high",
  "estimated_hours": 16,
  "phase": 5,
  "feature_area": "analytics",
  "tasks": [
    {
      "id": "ANALYTICS-001",
      "task_name": "Analytics Service Setup",
      "feature_details": "Create the analytics microservice for data aggregation.",
      "feature_dependency": ["MONGO-001", "MSG-001"],
      "ai_prompt": "Create analytics microservice:\n\n1. Create services/analytics-service/src/index.ts:\n   ```typescript\n   import Fastify from 'fastify';\n   import cors from '@fastify/cors';\n   import { analyticsRoutes } from './routes';\n   import { mongoPlugin } from './plugins/mongo';\n   import { authPlugin } from './plugins/auth';\n   import { config } from './config';\n\n   const app = Fastify({ logger: true });\n\n   async function start() {\n     await app.register(cors, { origin: config.corsOrigins });\n     await app.register(mongoPlugin);\n     await app.register(authPlugin);\n     await app.register(analyticsRoutes, { prefix: '/api/analytics' });\n\n     await app.listen({ port: config.port, host: '0.0.0.0' });\n   }\n\n   start();\n   ```\n\n2. Create services/analytics-service/src/config/index.ts:\n   ```typescript\n   export const config = {\n     port: parseInt(process.env.PORT || '3006'),\n     mongoUri: process.env.MONGODB_URI!,\n     corsOrigins: process.env.CORS_ORIGINS?.split(',') || ['http://localhost:3000'],\n     cacheEnabled: process.env.CACHE_ENABLED === 'true',\n     cacheTTL: parseInt(process.env.CACHE_TTL || '300'),\n   };\n   ```\n\n3. Project structure:\n   ```\n   services/analytics-service/\n   ├── src/\n   │   ├── index.ts\n   │   ├── config/\n   │   ├── routes/\n   │   ├── services/\n   │   ├── aggregations/\n   │   └── plugins/\n   ├── package.json\n   ├── tsconfig.json\n   └── Dockerfile\n   ```\n\n4. Docker configuration:\n   ```dockerfile\n   FROM node:20-alpine\n   WORKDIR /app\n   COPY package*.json ./\n   RUN npm ci --only=production\n   COPY dist/ ./dist/\n   EXPOSE 3006\n   CMD [\"node\", \"dist/index.js\"]\n   ```",
      "testing_instructions": {
        "unit_tests": [
          "Test config loading",
          "Test plugin registration"
        ],
        "integration_tests": [
          "Test service startup",
          "Test MongoDB connection"
        ],
        "e2e_tests": []
      },
      "acceptance_criteria": [
        "Service starts successfully",
        "MongoDB connection works",
        "Auth middleware applied",
        "Routes registered"
      ],
      "files_to_create": [
        "services/analytics-service/src/index.ts",
        "services/analytics-service/src/config/index.ts",
        "services/analytics-service/package.json",
        "services/analytics-service/tsconfig.json",
        "services/analytics-service/Dockerfile"
      ],
      "files_to_modify": [
        "docker-compose.yml"
      ],
      "docker_requirements": {
        "services": ["analytics-service"],
        "environment_variables": [
          "MONGODB_URI",
          "PORT",
          "CORS_ORIGINS"
        ],
        "volumes": [],
        "networks": ["caas-network"]
      },
      "api_endpoints": [],
      "database_changes": {
        "collections": [],
        "indexes": [],
        "migrations": []
      },
      "status": "not_started",
      "estimated_hours": 4,
      "tags": ["analytics", "setup", "microservice"]
    },
    {
      "id": "ANALYTICS-002",
      "task_name": "Message Analytics Aggregation",
      "feature_details": "Create MongoDB aggregation pipelines for message analytics.",
      "feature_dependency": ["ANALYTICS-001"],
      "ai_prompt": "Create message analytics aggregations:\n\n1. Create services/analytics-service/src/aggregations/messages.ts:\n   ```typescript\n   import { PipelineStage } from 'mongodb';\n\n   export function messageVolumeByDay(tenantId: string, startDate: Date, endDate: Date): PipelineStage[] {\n     return [\n       { $match: { \n         tenantId,\n         createdAt: { $gte: startDate, $lte: endDate }\n       }},\n       { $group: {\n         _id: { $dateToString: { format: '%Y-%m-%d', date: '$createdAt' }},\n         count: { $sum: 1 },\n         uniqueUsers: { $addToSet: '$senderId' }\n       }},\n       { $project: {\n         _id: 0,\n         date: '$_id',\n         messageCount: '$count',\n         activeUsers: { $size: '$uniqueUsers' }\n       }},\n       { $sort: { date: 1 }}\n     ];\n   }\n\n   export function messagesByType(tenantId: string, startDate: Date, endDate: Date): PipelineStage[] {\n     return [\n       { $match: { \n         tenantId,\n         createdAt: { $gte: startDate, $lte: endDate }\n       }},\n       { $group: {\n         _id: '$type',\n         count: { $sum: 1 }\n       }},\n       { $project: {\n         _id: 0,\n         type: '$_id',\n         count: 1,\n         percentage: { $multiply: [{ $divide: ['$count', { $sum: '$count' }]}, 100]}\n       }}\n     ];\n   }\n\n   export function topConversations(tenantId: string, limit: number = 10): PipelineStage[] {\n     return [\n       { $match: { tenantId }},\n       { $group: {\n         _id: '$conversationId',\n         messageCount: { $sum: 1 },\n         lastActivity: { $max: '$createdAt' }\n       }},\n       { $sort: { messageCount: -1 }},\n       { $limit: limit },\n       { $lookup: {\n         from: 'conversations',\n         localField: '_id',\n         foreignField: '_id',\n         as: 'conversation'\n       }},\n       { $unwind: '$conversation' },\n       { $project: {\n         conversationId: '$_id',\n         name: '$conversation.name',\n         messageCount: 1,\n         lastActivity: 1\n       }}\n     ];\n   }\n\n   export function hourlyDistribution(tenantId: string, days: number = 7): PipelineStage[] {\n     const startDate = new Date();\n     startDate.setDate(startDate.getDate() - days);\n     \n     return [\n       { $match: { \n         tenantId,\n         createdAt: { $gte: startDate }\n       }},\n       { $group: {\n         _id: { $hour: '$createdAt' },\n         count: { $sum: 1 }\n       }},\n       { $sort: { _id: 1 }},\n       { $project: {\n         _id: 0,\n         hour: '$_id',\n         count: 1\n       }}\n     ];\n   }\n   ```\n\n2. Create services/analytics-service/src/services/message-analytics.ts:\n   ```typescript\n   import { Db } from 'mongodb';\n   import { messageVolumeByDay, messagesByType, topConversations, hourlyDistribution } from '../aggregations/messages';\n\n   export class MessageAnalyticsService {\n     constructor(private db: Db) {}\n\n     async getMessageVolume(tenantId: string, startDate: Date, endDate: Date) {\n       return this.db.collection('messages')\n         .aggregate(messageVolumeByDay(tenantId, startDate, endDate))\n         .toArray();\n     }\n\n     async getMessageTypeBreakdown(tenantId: string, startDate: Date, endDate: Date) {\n       return this.db.collection('messages')\n         .aggregate(messagesByType(tenantId, startDate, endDate))\n         .toArray();\n     }\n\n     async getTopConversations(tenantId: string, limit?: number) {\n       return this.db.collection('messages')\n         .aggregate(topConversations(tenantId, limit))\n         .toArray();\n     }\n\n     async getHourlyDistribution(tenantId: string, days?: number) {\n       return this.db.collection('messages')\n         .aggregate(hourlyDistribution(tenantId, days))\n         .toArray();\n     }\n   }\n   ```",
      "testing_instructions": {
        "unit_tests": [
          "Test aggregation pipelines",
          "Test date range handling"
        ],
        "integration_tests": [
          "Test with real MongoDB data",
          "Test performance with large datasets"
        ],
        "e2e_tests": []
      },
      "acceptance_criteria": [
        "Message volume aggregation works",
        "Type breakdown works",
        "Top conversations works",
        "Hourly distribution works"
      ],
      "files_to_create": [
        "services/analytics-service/src/aggregations/messages.ts",
        "services/analytics-service/src/services/message-analytics.ts"
      ],
      "files_to_modify": [],
      "docker_requirements": {
        "services": [],
        "environment_variables": [],
        "volumes": [],
        "networks": []
      },
      "api_endpoints": [],
      "database_changes": {
        "collections": [],
        "indexes": [
          {
            "collection": "messages",
            "keys": { "tenantId": 1, "createdAt": -1 },
            "options": { "name": "analytics_messages_by_date" }
          }
        ],
        "migrations": []
      },
      "status": "not_started",
      "estimated_hours": 4,
      "tags": ["analytics", "messages", "aggregation"]
    },
    {
      "id": "ANALYTICS-003",
      "task_name": "User Analytics Aggregation",
      "feature_details": "Create aggregation pipelines for user activity analytics.",
      "feature_dependency": ["ANALYTICS-001"],
      "ai_prompt": "Create user analytics aggregations:\n\n1. Create services/analytics-service/src/aggregations/users.ts:\n   ```typescript\n   import { PipelineStage } from 'mongodb';\n\n   export function activeUsersByDay(tenantId: string, startDate: Date, endDate: Date): PipelineStage[] {\n     return [\n       { $match: { \n         tenantId,\n         createdAt: { $gte: startDate, $lte: endDate }\n       }},\n       { $group: {\n         _id: { $dateToString: { format: '%Y-%m-%d', date: '$createdAt' }},\n         uniqueUsers: { $addToSet: '$senderId' }\n       }},\n       { $project: {\n         _id: 0,\n         date: '$_id',\n         dau: { $size: '$uniqueUsers' }\n       }},\n       { $sort: { date: 1 }}\n     ];\n   }\n\n   export function userEngagementMetrics(tenantId: string, userId: string): PipelineStage[] {\n     return [\n       { $match: { tenantId, senderId: userId }},\n       { $facet: {\n         totalMessages: [{ $count: 'count' }],\n         conversationsActive: [{ $group: { _id: '$conversationId' }}, { $count: 'count' }],\n         messageTypes: [{ $group: { _id: '$type', count: { $sum: 1 }}}],\n         firstMessage: [{ $sort: { createdAt: 1 }}, { $limit: 1 }],\n         lastMessage: [{ $sort: { createdAt: -1 }}, { $limit: 1 }]\n       }}\n     ];\n   }\n\n   export function topActiveUsers(tenantId: string, startDate: Date, endDate: Date, limit: number = 10): PipelineStage[] {\n     return [\n       { $match: { \n         tenantId,\n         createdAt: { $gte: startDate, $lte: endDate }\n       }},\n       { $group: {\n         _id: '$senderId',\n         messageCount: { $sum: 1 },\n         conversationCount: { $addToSet: '$conversationId' },\n         lastActive: { $max: '$createdAt' }\n       }},\n       { $project: {\n         userId: '$_id',\n         messageCount: 1,\n         conversationCount: { $size: '$conversationCount' },\n         lastActive: 1\n       }},\n       { $sort: { messageCount: -1 }},\n       { $limit: limit },\n       { $lookup: {\n         from: 'users',\n         localField: 'userId',\n         foreignField: '_id',\n         as: 'user'\n       }},\n       { $unwind: '$user' },\n       { $project: {\n         userId: 1,\n         displayName: '$user.displayName',\n         messageCount: 1,\n         conversationCount: 1,\n         lastActive: 1\n       }}\n     ];\n   }\n\n   export function userGrowth(tenantId: string, startDate: Date, endDate: Date): PipelineStage[] {\n     return [\n       { $match: { \n         tenantId,\n         createdAt: { $gte: startDate, $lte: endDate }\n       }},\n       { $group: {\n         _id: { $dateToString: { format: '%Y-%m-%d', date: '$createdAt' }},\n         newUsers: { $sum: 1 }\n       }},\n       { $sort: { _id: 1 }},\n       { $group: {\n         _id: null,\n         data: { $push: { date: '$_id', newUsers: '$newUsers' }}\n       }},\n       { $unwind: { path: '$data', includeArrayIndex: 'index' }},\n       { $project: {\n         date: '$data.date',\n         newUsers: '$data.newUsers',\n         cumulativeUsers: {\n           $sum: {\n             $map: {\n               input: { $slice: ['$data', { $add: ['$index', 1] }]},\n               as: 'd',\n               in: '$$d.newUsers'\n             }\n           }\n         }\n       }}\n     ];\n   }\n   ```\n\n2. Create services/analytics-service/src/services/user-analytics.ts:\n   ```typescript\n   import { Db } from 'mongodb';\n   import { activeUsersByDay, userEngagementMetrics, topActiveUsers, userGrowth } from '../aggregations/users';\n\n   export class UserAnalyticsService {\n     constructor(private db: Db) {}\n\n     async getDAU(tenantId: string, startDate: Date, endDate: Date) {\n       return this.db.collection('messages')\n         .aggregate(activeUsersByDay(tenantId, startDate, endDate))\n         .toArray();\n     }\n\n     async getUserEngagement(tenantId: string, userId: string) {\n       const result = await this.db.collection('messages')\n         .aggregate(userEngagementMetrics(tenantId, userId))\n         .toArray();\n       return result[0];\n     }\n\n     async getTopActiveUsers(tenantId: string, startDate: Date, endDate: Date, limit?: number) {\n       return this.db.collection('messages')\n         .aggregate(topActiveUsers(tenantId, startDate, endDate, limit))\n         .toArray();\n     }\n\n     async getUserGrowth(tenantId: string, startDate: Date, endDate: Date) {\n       return this.db.collection('users')\n         .aggregate(userGrowth(tenantId, startDate, endDate))\n         .toArray();\n     }\n   }\n   ```",
      "testing_instructions": {
        "unit_tests": [
          "Test aggregation pipelines",
          "Test date calculations"
        ],
        "integration_tests": [
          "Test DAU calculation",
          "Test user engagement"
        ],
        "e2e_tests": []
      },
      "acceptance_criteria": [
        "DAU aggregation works",
        "User engagement works",
        "Top users works",
        "User growth works"
      ],
      "files_to_create": [
        "services/analytics-service/src/aggregations/users.ts",
        "services/analytics-service/src/services/user-analytics.ts"
      ],
      "files_to_modify": [],
      "docker_requirements": {
        "services": [],
        "environment_variables": [],
        "volumes": [],
        "networks": []
      },
      "api_endpoints": [],
      "database_changes": {
        "collections": [],
        "indexes": [
          {
            "collection": "messages",
            "keys": { "tenantId": 1, "senderId": 1, "createdAt": -1 },
            "options": { "name": "analytics_user_activity" }
          }
        ],
        "migrations": []
      },
      "status": "not_started",
      "estimated_hours": 4,
      "tags": ["analytics", "users", "aggregation"]
    },
    {
      "id": "ANALYTICS-004",
      "task_name": "Analytics API Routes",
      "feature_details": "Create REST API routes for analytics data access.",
      "feature_dependency": ["ANALYTICS-002", "ANALYTICS-003"],
      "ai_prompt": "Create analytics API routes:\n\n1. Create services/analytics-service/src/routes/index.ts:\n   ```typescript\n   import { FastifyPluginAsync } from 'fastify';\n   import { z } from 'zod';\n   import { MessageAnalyticsService } from '../services/message-analytics';\n   import { UserAnalyticsService } from '../services/user-analytics';\n\n   const dateRangeSchema = z.object({\n     startDate: z.string().transform(s => new Date(s)),\n     endDate: z.string().transform(s => new Date(s)),\n   });\n\n   export const analyticsRoutes: FastifyPluginAsync = async (fastify) => {\n     const messageAnalytics = new MessageAnalyticsService(fastify.mongo.db);\n     const userAnalytics = new UserAnalyticsService(fastify.mongo.db);\n\n     // Message Analytics\n     fastify.get('/messages/volume', {\n       preHandler: [fastify.authenticate],\n       handler: async (request) => {\n         const { startDate, endDate } = dateRangeSchema.parse(request.query);\n         return messageAnalytics.getMessageVolume(\n           request.tenantId,\n           startDate,\n           endDate\n         );\n       }\n     });\n\n     fastify.get('/messages/types', {\n       preHandler: [fastify.authenticate],\n       handler: async (request) => {\n         const { startDate, endDate } = dateRangeSchema.parse(request.query);\n         return messageAnalytics.getMessageTypeBreakdown(\n           request.tenantId,\n           startDate,\n           endDate\n         );\n       }\n     });\n\n     fastify.get('/messages/top-conversations', {\n       preHandler: [fastify.authenticate],\n       handler: async (request) => {\n         const { limit } = z.object({ limit: z.number().optional() }).parse(request.query);\n         return messageAnalytics.getTopConversations(request.tenantId, limit);\n       }\n     });\n\n     fastify.get('/messages/hourly', {\n       preHandler: [fastify.authenticate],\n       handler: async (request) => {\n         const { days } = z.object({ days: z.number().optional() }).parse(request.query);\n         return messageAnalytics.getHourlyDistribution(request.tenantId, days);\n       }\n     });\n\n     // User Analytics\n     fastify.get('/users/dau', {\n       preHandler: [fastify.authenticate],\n       handler: async (request) => {\n         const { startDate, endDate } = dateRangeSchema.parse(request.query);\n         return userAnalytics.getDAU(request.tenantId, startDate, endDate);\n       }\n     });\n\n     fastify.get('/users/top', {\n       preHandler: [fastify.authenticate],\n       handler: async (request) => {\n         const { startDate, endDate, limit } = z.object({\n           startDate: z.string().transform(s => new Date(s)),\n           endDate: z.string().transform(s => new Date(s)),\n           limit: z.number().optional()\n         }).parse(request.query);\n         return userAnalytics.getTopActiveUsers(\n           request.tenantId,\n           startDate,\n           endDate,\n           limit\n         );\n       }\n     });\n\n     fastify.get('/users/:userId', {\n       preHandler: [fastify.authenticate],\n       handler: async (request) => {\n         const { userId } = request.params as { userId: string };\n         return userAnalytics.getUserEngagement(request.tenantId, userId);\n       }\n     });\n\n     fastify.get('/users/growth', {\n       preHandler: [fastify.authenticate],\n       handler: async (request) => {\n         const { startDate, endDate } = dateRangeSchema.parse(request.query);\n         return userAnalytics.getUserGrowth(request.tenantId, startDate, endDate);\n       }\n     });\n\n     // Dashboard summary\n     fastify.get('/dashboard', {\n       preHandler: [fastify.authenticate],\n       handler: async (request) => {\n         const now = new Date();\n         const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n         const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n\n         const [messageVolume, dau, topConversations, messageTypes] = await Promise.all([\n           messageAnalytics.getMessageVolume(request.tenantId, thirtyDaysAgo, now),\n           userAnalytics.getDAU(request.tenantId, sevenDaysAgo, now),\n           messageAnalytics.getTopConversations(request.tenantId, 5),\n           messageAnalytics.getMessageTypeBreakdown(request.tenantId, sevenDaysAgo, now)\n         ]);\n\n         return { messageVolume, dau, topConversations, messageTypes };\n       }\n     });\n   };\n   ```\n\n2. Add response caching:\n   ```typescript\n   fastify.register(require('@fastify/caching'), {\n     privacy: 'private',\n     expiresIn: 300 // 5 minutes\n   });\n   ```\n\n3. Add rate limiting for analytics:\n   ```typescript\n   fastify.register(require('@fastify/rate-limit'), {\n     max: 100,\n     timeWindow: '1 minute'\n   });\n   ```",
      "testing_instructions": {
        "unit_tests": [
          "Test route schemas",
          "Test date parsing"
        ],
        "integration_tests": [
          "Test API endpoints",
          "Test authentication",
          "Test caching"
        ],
        "e2e_tests": [
          "Test dashboard endpoint"
        ]
      },
      "acceptance_criteria": [
        "All routes accessible",
        "Authentication required",
        "Tenant isolation enforced",
        "Response caching works"
      ],
      "files_to_create": [
        "services/analytics-service/src/routes/index.ts",
        "services/analytics-service/src/routes/messages.ts",
        "services/analytics-service/src/routes/users.ts"
      ],
      "files_to_modify": [],
      "docker_requirements": {
        "services": [],
        "environment_variables": [],
        "volumes": [],
        "networks": []
      },
      "api_endpoints": [
        {
          "method": "GET",
          "path": "/api/analytics/messages/volume",
          "description": "Get message volume by day"
        },
        {
          "method": "GET",
          "path": "/api/analytics/messages/types",
          "description": "Get message type breakdown"
        },
        {
          "method": "GET",
          "path": "/api/analytics/messages/top-conversations",
          "description": "Get top conversations"
        },
        {
          "method": "GET",
          "path": "/api/analytics/users/dau",
          "description": "Get daily active users"
        },
        {
          "method": "GET",
          "path": "/api/analytics/users/top",
          "description": "Get top active users"
        },
        {
          "method": "GET",
          "path": "/api/analytics/dashboard",
          "description": "Get dashboard summary"
        }
      ],
      "database_changes": {
        "collections": [],
        "indexes": [],
        "migrations": []
      },
      "status": "not_started",
      "estimated_hours": 4,
      "tags": ["analytics", "api", "routes"]
    }
  ]
}
