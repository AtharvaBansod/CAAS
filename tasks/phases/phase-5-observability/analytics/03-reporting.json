{
  "task_group": "reporting",
  "description": "Report generation and export functionality",
  "priority": "medium",
  "estimated_hours": 12,
  "phase": 5,
  "feature_area": "analytics",
  "tasks": [
    {
      "id": "ANALYTICS-009",
      "task_name": "CSV Export Service",
      "feature_details": "Create CSV export functionality for analytics data.",
      "feature_dependency": ["ANALYTICS-004"],
      "ai_prompt": "Create CSV export service:\n\n1. Create services/analytics-service/src/services/export/csv-exporter.ts:\n   ```typescript\n   import { Transform } from 'stream';\n\n   export interface CSVOptions {\n     headers: string[];\n     delimiter?: string;\n   }\n\n   export function createCSVTransform(options: CSVOptions): Transform {\n     const { headers, delimiter = ',' } = options;\n     let headerWritten = false;\n\n     return new Transform({\n       objectMode: true,\n       transform(row, encoding, callback) {\n         if (!headerWritten) {\n           this.push(headers.join(delimiter) + '\\n');\n           headerWritten = true;\n         }\n\n         const values = headers.map(header => {\n           const value = row[header];\n           if (typeof value === 'string' && value.includes(delimiter)) {\n             return `\"${value.replace(/\"/g, '\"\"')}\"`;\n           }\n           return value ?? '';\n         });\n\n         this.push(values.join(delimiter) + '\\n');\n         callback();\n       }\n     });\n   }\n\n   export class CSVExporter {\n     async exportMessages(data: any[]): Promise<string> {\n       const headers = ['date', 'messageCount', 'activeUsers', 'avgResponseTime'];\n       let csv = headers.join(',') + '\\n';\n       \n       for (const row of data) {\n         csv += headers.map(h => this.escapeValue(row[h])).join(',') + '\\n';\n       }\n       \n       return csv;\n     }\n\n     async exportUsers(data: any[]): Promise<string> {\n       const headers = ['userId', 'displayName', 'messageCount', 'conversationCount', 'lastActive'];\n       let csv = headers.join(',') + '\\n';\n       \n       for (const row of data) {\n         csv += headers.map(h => this.escapeValue(row[h])).join(',') + '\\n';\n       }\n       \n       return csv;\n     }\n\n     private escapeValue(value: any): string {\n       if (value === null || value === undefined) return '';\n       const str = String(value);\n       if (str.includes(',') || str.includes('\"') || str.includes('\\n')) {\n         return `\"${str.replace(/\"/g, '\"\"')}\"`;\n       }\n       return str;\n     }\n   }\n   ```\n\n2. Create export routes:\n   ```typescript\n   fastify.get('/export/messages', {\n     preHandler: [fastify.authenticate],\n     handler: async (request, reply) => {\n       const { startDate, endDate, format } = request.query;\n       \n       const data = await messageAnalytics.getMessageVolume(\n         request.tenantId,\n         new Date(startDate),\n         new Date(endDate)\n       );\n\n       const exporter = new CSVExporter();\n       const csv = await exporter.exportMessages(data);\n\n       reply\n         .header('Content-Type', 'text/csv')\n         .header('Content-Disposition', 'attachment; filename=\"messages.csv\"')\n         .send(csv);\n     }\n   });\n\n   fastify.get('/export/users', {\n     preHandler: [fastify.authenticate],\n     handler: async (request, reply) => {\n       const { startDate, endDate } = request.query;\n       \n       const data = await userAnalytics.getTopActiveUsers(\n         request.tenantId,\n         new Date(startDate),\n         new Date(endDate),\n         1000 // Max users to export\n       );\n\n       const exporter = new CSVExporter();\n       const csv = await exporter.exportUsers(data);\n\n       reply\n         .header('Content-Type', 'text/csv')\n         .header('Content-Disposition', 'attachment; filename=\"users.csv\"')\n         .send(csv);\n     }\n   });\n   ```\n\n3. Stream large exports:\n   ```typescript\n   fastify.get('/export/stream/messages', {\n     handler: async (request, reply) => {\n       const cursor = db.collection('messages')\n         .aggregate(pipeline)\n         .stream();\n\n       const csvTransform = createCSVTransform({\n         headers: ['date', 'messageCount', 'activeUsers']\n       });\n\n       reply\n         .header('Content-Type', 'text/csv')\n         .header('Transfer-Encoding', 'chunked')\n         .send(cursor.pipe(csvTransform));\n     }\n   });\n   ```",
      "testing_instructions": {
        "unit_tests": [
          "Test CSV escaping",
          "Test header generation"
        ],
        "integration_tests": [
          "Test export endpoints",
          "Test large data streaming"
        ],
        "e2e_tests": []
      },
      "acceptance_criteria": [
        "CSV export works",
        "Special characters escaped",
        "Large exports stream correctly",
        "Proper headers set"
      ],
      "files_to_create": [
        "services/analytics-service/src/services/export/csv-exporter.ts",
        "services/analytics-service/src/routes/export.ts"
      ],
      "files_to_modify": [],
      "docker_requirements": {
        "services": [],
        "environment_variables": [],
        "volumes": [],
        "networks": []
      },
      "api_endpoints": [
        {
          "method": "GET",
          "path": "/api/analytics/export/messages",
          "description": "Export message analytics as CSV"
        },
        {
          "method": "GET",
          "path": "/api/analytics/export/users",
          "description": "Export user analytics as CSV"
        }
      ],
      "database_changes": {
        "collections": [],
        "indexes": [],
        "migrations": []
      },
      "status": "not_started",
      "estimated_hours": 4,
      "tags": ["analytics", "export", "csv"]
    },
    {
      "id": "ANALYTICS-010",
      "task_name": "PDF Report Generator",
      "feature_details": "Create PDF report generation for analytics summaries.",
      "feature_dependency": ["ANALYTICS-002", "ANALYTICS-003"],
      "ai_prompt": "Create PDF report generator:\n\n1. Create services/analytics-service/src/services/export/pdf-generator.ts:\n   ```typescript\n   import PDFDocument from 'pdfkit';\n   import { ChartJSNodeCanvas } from 'chartjs-node-canvas';\n\n   const chartCanvas = new ChartJSNodeCanvas({ width: 600, height: 300 });\n\n   export interface ReportData {\n     tenantName: string;\n     dateRange: { start: Date; end: Date };\n     summary: {\n       totalMessages: number;\n       activeUsers: number;\n       totalConversations: number;\n     };\n     messageVolume: { date: string; count: number }[];\n     topConversations: { name: string; messageCount: number }[];\n     topUsers: { displayName: string; messageCount: number }[];\n   }\n\n   export class PDFReportGenerator {\n     async generate(data: ReportData): Promise<Buffer> {\n       return new Promise((resolve, reject) => {\n         const chunks: Buffer[] = [];\n         const doc = new PDFDocument({ margin: 50 });\n\n         doc.on('data', chunks.push.bind(chunks));\n         doc.on('end', () => resolve(Buffer.concat(chunks)));\n         doc.on('error', reject);\n\n         this.addHeader(doc, data);\n         this.addSummary(doc, data.summary);\n         this.addCharts(doc, data);\n         this.addTables(doc, data);\n         this.addFooter(doc);\n\n         doc.end();\n       });\n     }\n\n     private addHeader(doc: PDFKit.PDFDocument, data: ReportData) {\n       doc\n         .fontSize(24)\n         .text('Analytics Report', { align: 'center' })\n         .fontSize(12)\n         .text(data.tenantName, { align: 'center' })\n         .text(\n           `${data.dateRange.start.toLocaleDateString()} - ${data.dateRange.end.toLocaleDateString()}`,\n           { align: 'center' }\n         )\n         .moveDown(2);\n     }\n\n     private addSummary(doc: PDFKit.PDFDocument, summary: ReportData['summary']) {\n       doc\n         .fontSize(16)\n         .text('Summary')\n         .fontSize(12)\n         .moveDown(0.5);\n\n       const summaryTable = [\n         ['Metric', 'Value'],\n         ['Total Messages', summary.totalMessages.toLocaleString()],\n         ['Active Users', summary.activeUsers.toLocaleString()],\n         ['Total Conversations', summary.totalConversations.toLocaleString()],\n       ];\n\n       this.drawTable(doc, summaryTable, 200);\n       doc.moveDown(2);\n     }\n\n     private async addCharts(doc: PDFKit.PDFDocument, data: ReportData) {\n       // Generate message volume chart\n       const chartConfig = {\n         type: 'line',\n         data: {\n           labels: data.messageVolume.map(d => d.date),\n           datasets: [{\n             label: 'Messages',\n             data: data.messageVolume.map(d => d.count),\n             borderColor: '#8884d8',\n             fill: false,\n           }],\n         },\n         options: {\n           plugins: { title: { display: true, text: 'Message Volume' }},\n         },\n       };\n\n       const chartBuffer = await chartCanvas.renderToBuffer(chartConfig);\n       doc.image(chartBuffer, { width: 500, align: 'center' });\n       doc.moveDown(2);\n     }\n\n     private addTables(doc: PDFKit.PDFDocument, data: ReportData) {\n       doc.fontSize(14).text('Top Conversations').moveDown(0.5);\n       \n       const convTable = [\n         ['Conversation', 'Messages'],\n         ...data.topConversations.slice(0, 10).map(c => [c.name, c.messageCount.toString()])\n       ];\n       this.drawTable(doc, convTable, 400);\n       \n       doc.moveDown(2).fontSize(14).text('Top Users').moveDown(0.5);\n       \n       const userTable = [\n         ['User', 'Messages'],\n         ...data.topUsers.slice(0, 10).map(u => [u.displayName, u.messageCount.toString()])\n       ];\n       this.drawTable(doc, userTable, 400);\n     }\n\n     private drawTable(doc: PDFKit.PDFDocument, data: string[][], width: number) {\n       const colWidth = width / data[0].length;\n       const startX = doc.x;\n       let y = doc.y;\n\n       for (let i = 0; i < data.length; i++) {\n         const row = data[i];\n         let x = startX;\n         \n         for (const cell of row) {\n           doc.fontSize(i === 0 ? 10 : 9)\n              .text(cell, x, y, { width: colWidth - 10 });\n           x += colWidth;\n         }\n         y += 20;\n       }\n       \n       doc.y = y;\n     }\n\n     private addFooter(doc: PDFKit.PDFDocument) {\n       doc\n         .fontSize(8)\n         .text(\n           `Generated on ${new Date().toLocaleString()}`,\n           50,\n           doc.page.height - 50,\n           { align: 'center' }\n         );\n     }\n   }\n   ```\n\n2. Add PDF export route:\n   ```typescript\n   fastify.get('/export/report', {\n     preHandler: [fastify.authenticate],\n     handler: async (request, reply) => {\n       const { startDate, endDate } = request.query;\n\n       const [messageVolume, topConversations, topUsers, summary] = await Promise.all([\n         messageAnalytics.getMessageVolume(request.tenantId, startDate, endDate),\n         messageAnalytics.getTopConversations(request.tenantId, 10),\n         userAnalytics.getTopActiveUsers(request.tenantId, startDate, endDate, 10),\n         getSummaryStats(request.tenantId, startDate, endDate),\n       ]);\n\n       const generator = new PDFReportGenerator();\n       const pdf = await generator.generate({\n         tenantName: request.tenant.name,\n         dateRange: { start: startDate, end: endDate },\n         summary,\n         messageVolume,\n         topConversations,\n         topUsers,\n       });\n\n       reply\n         .header('Content-Type', 'application/pdf')\n         .header('Content-Disposition', 'attachment; filename=\"analytics-report.pdf\"')\n         .send(pdf);\n     }\n   });\n   ```",
      "testing_instructions": {
        "unit_tests": [
          "Test PDF generation",
          "Test chart rendering"
        ],
        "integration_tests": [
          "Test full report generation",
          "Test large data handling"
        ],
        "e2e_tests": []
      },
      "acceptance_criteria": [
        "PDF generates correctly",
        "Charts included",
        "Tables formatted",
        "Proper styling"
      ],
      "files_to_create": [
        "services/analytics-service/src/services/export/pdf-generator.ts"
      ],
      "files_to_modify": [
        "services/analytics-service/src/routes/export.ts"
      ],
      "docker_requirements": {
        "services": [],
        "environment_variables": [],
        "volumes": [],
        "networks": []
      },
      "api_endpoints": [
        {
          "method": "GET",
          "path": "/api/analytics/export/report",
          "description": "Generate PDF analytics report"
        }
      ],
      "database_changes": {
        "collections": [],
        "indexes": [],
        "migrations": []
      },
      "status": "not_started",
      "estimated_hours": 4,
      "tags": ["analytics", "export", "pdf"]
    },
    {
      "id": "ANALYTICS-011",
      "task_name": "Scheduled Reports",
      "feature_details": "Create scheduled report generation and delivery.",
      "feature_dependency": ["ANALYTICS-009", "ANALYTICS-010"],
      "ai_prompt": "Create scheduled report system:\n\n1. Create services/analytics-service/src/services/scheduler/report-scheduler.ts:\n   ```typescript\n   import cron from 'node-cron';\n   import { Db, ObjectId } from 'mongodb';\n   import { PDFReportGenerator } from '../export/pdf-generator';\n   import { CSVExporter } from '../export/csv-exporter';\n   import { EmailService } from '../email/email-service';\n\n   interface ScheduledReport {\n     _id: ObjectId;\n     tenantId: string;\n     name: string;\n     type: 'daily' | 'weekly' | 'monthly';\n     format: 'pdf' | 'csv';\n     recipients: string[];\n     metrics: string[];\n     enabled: boolean;\n     lastRun?: Date;\n     nextRun: Date;\n   }\n\n   export class ReportScheduler {\n     private jobs: Map<string, cron.ScheduledTask> = new Map();\n\n     constructor(\n       private db: Db,\n       private emailService: EmailService,\n       private pdfGenerator: PDFReportGenerator,\n       private csvExporter: CSVExporter\n     ) {}\n\n     async start() {\n       // Run every hour to check for due reports\n       cron.schedule('0 * * * *', () => this.checkScheduledReports());\n       \n       // Load existing schedules\n       await this.loadSchedules();\n     }\n\n     private async loadSchedules() {\n       const schedules = await this.db.collection<ScheduledReport>('scheduled_reports')\n         .find({ enabled: true })\n         .toArray();\n\n       for (const schedule of schedules) {\n         this.scheduleReport(schedule);\n       }\n     }\n\n     private scheduleReport(schedule: ScheduledReport) {\n       const cronExpression = this.getCronExpression(schedule.type);\n       \n       const task = cron.schedule(cronExpression, async () => {\n         await this.runReport(schedule);\n       });\n\n       this.jobs.set(schedule._id.toString(), task);\n     }\n\n     private getCronExpression(type: string): string {\n       switch (type) {\n         case 'daily': return '0 8 * * *'; // 8 AM daily\n         case 'weekly': return '0 8 * * 1'; // 8 AM Monday\n         case 'monthly': return '0 8 1 * *'; // 8 AM 1st of month\n         default: return '0 8 * * *';\n       }\n     }\n\n     private async runReport(schedule: ScheduledReport) {\n       try {\n         const dateRange = this.getDateRange(schedule.type);\n         const data = await this.gatherReportData(schedule.tenantId, dateRange);\n\n         let attachment: Buffer;\n         let filename: string;\n         let mimeType: string;\n\n         if (schedule.format === 'pdf') {\n           attachment = await this.pdfGenerator.generate(data);\n           filename = `report-${Date.now()}.pdf`;\n           mimeType = 'application/pdf';\n         } else {\n           const csv = await this.csvExporter.exportMessages(data.messageVolume);\n           attachment = Buffer.from(csv);\n           filename = `report-${Date.now()}.csv`;\n           mimeType = 'text/csv';\n         }\n\n         await this.emailService.sendWithAttachment({\n           to: schedule.recipients,\n           subject: `${schedule.name} - ${schedule.type.charAt(0).toUpperCase() + schedule.type.slice(1)} Report`,\n           html: this.generateEmailBody(schedule, dateRange),\n           attachments: [{ filename, content: attachment, contentType: mimeType }],\n         });\n\n         await this.db.collection('scheduled_reports').updateOne(\n           { _id: schedule._id },\n           { $set: { lastRun: new Date(), nextRun: this.getNextRunDate(schedule.type) }}\n         );\n       } catch (error) {\n         console.error(`Failed to run report ${schedule._id}:`, error);\n         // Store error for debugging\n         await this.db.collection('report_errors').insertOne({\n           scheduleId: schedule._id,\n           error: error.message,\n           timestamp: new Date(),\n         });\n       }\n     }\n\n     private getDateRange(type: string): { start: Date; end: Date } {\n       const end = new Date();\n       const start = new Date();\n       \n       switch (type) {\n         case 'daily':\n           start.setDate(start.getDate() - 1);\n           break;\n         case 'weekly':\n           start.setDate(start.getDate() - 7);\n           break;\n         case 'monthly':\n           start.setMonth(start.getMonth() - 1);\n           break;\n       }\n       \n       return { start, end };\n     }\n   }\n   ```\n\n2. Create schedule management API:\n   ```typescript\n   fastify.post('/reports/schedule', {\n     preHandler: [fastify.authenticate],\n     handler: async (request) => {\n       const schedule = {\n         ...request.body,\n         tenantId: request.tenantId,\n         enabled: true,\n         nextRun: calculateNextRun(request.body.type),\n       };\n       \n       const result = await db.collection('scheduled_reports').insertOne(schedule);\n       scheduler.scheduleReport({ ...schedule, _id: result.insertedId });\n       \n       return { id: result.insertedId };\n     }\n   });\n\n   fastify.get('/reports/schedule', {\n     preHandler: [fastify.authenticate],\n     handler: async (request) => {\n       return db.collection('scheduled_reports')\n         .find({ tenantId: request.tenantId })\n         .toArray();\n     }\n   });\n\n   fastify.delete('/reports/schedule/:id', {\n     preHandler: [fastify.authenticate],\n     handler: async (request) => {\n       const { id } = request.params;\n       await db.collection('scheduled_reports').deleteOne({\n         _id: new ObjectId(id),\n         tenantId: request.tenantId,\n       });\n       scheduler.cancelReport(id);\n       return { success: true };\n     }\n   });\n   ```",
      "testing_instructions": {
        "unit_tests": [
          "Test cron expressions",
          "Test date range calculation"
        ],
        "integration_tests": [
          "Test schedule creation",
          "Test report generation"
        ],
        "e2e_tests": [
          "Test full scheduled report cycle"
        ]
      },
      "acceptance_criteria": [
        "Schedules persist",
        "Reports generate on time",
        "Email delivery works",
        "Error handling works"
      ],
      "files_to_create": [
        "services/analytics-service/src/services/scheduler/report-scheduler.ts",
        "services/analytics-service/src/routes/schedules.ts"
      ],
      "files_to_modify": [],
      "docker_requirements": {
        "services": [],
        "environment_variables": [
          "SMTP_HOST",
          "SMTP_PORT",
          "SMTP_USER",
          "SMTP_PASSWORD"
        ],
        "volumes": [],
        "networks": []
      },
      "api_endpoints": [
        {
          "method": "POST",
          "path": "/api/analytics/reports/schedule",
          "description": "Create scheduled report"
        },
        {
          "method": "GET",
          "path": "/api/analytics/reports/schedule",
          "description": "List scheduled reports"
        },
        {
          "method": "DELETE",
          "path": "/api/analytics/reports/schedule/:id",
          "description": "Delete scheduled report"
        }
      ],
      "database_changes": {
        "collections": [
          {
            "name": "scheduled_reports",
            "description": "Scheduled report configurations"
          }
        ],
        "indexes": [
          {
            "collection": "scheduled_reports",
            "keys": { "tenantId": 1, "enabled": 1 },
            "options": { "name": "scheduled_reports_tenant" }
          }
        ],
        "migrations": []
      },
      "status": "not_started",
      "estimated_hours": 4,
      "tags": ["analytics", "scheduler", "email"]
    }
  ]
}
