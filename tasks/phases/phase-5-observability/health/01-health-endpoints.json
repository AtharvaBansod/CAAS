{
  "task_group": "health-endpoints",
  "description": "Health check endpoints for all services",
  "priority": "high",
  "estimated_hours": 12,
  "phase": 5,
  "feature_area": "health",
  "tasks": [
    {
      "id": "HEALTH-001",
      "task_name": "Health Check Library",
      "feature_details": "Create shared health check library for all services.",
      "feature_dependency": [],
      "ai_prompt": "Create health check library:\n\n1. Create packages/health-check/src/index.ts:\n   ```typescript\n   export interface HealthCheckResult {\n     status: 'healthy' | 'degraded' | 'unhealthy';\n     timestamp: string;\n     version: string;\n     uptime: number;\n     checks: Record<string, DependencyCheck>;\n   }\n\n   export interface DependencyCheck {\n     status: 'healthy' | 'unhealthy';\n     latency?: number;\n     message?: string;\n     lastCheck: string;\n   }\n\n   export interface HealthChecker {\n     name: string;\n     check: () => Promise<DependencyCheck>;\n     critical?: boolean; // If true, failing makes service unhealthy\n   }\n\n   export class HealthCheckService {\n     private checkers: Map<string, HealthChecker> = new Map();\n     private startTime = Date.now();\n     private version: string;\n\n     constructor(version: string) {\n       this.version = version;\n     }\n\n     register(checker: HealthChecker) {\n       this.checkers.set(checker.name, checker);\n     }\n\n     async liveness(): Promise<{ status: 'ok' }> {\n       return { status: 'ok' };\n     }\n\n     async readiness(): Promise<HealthCheckResult> {\n       const checks: Record<string, DependencyCheck> = {};\n       let hasCriticalFailure = false;\n       let hasDegradation = false;\n\n       await Promise.all(\n         Array.from(this.checkers.entries()).map(async ([name, checker]) => {\n           try {\n             const start = Date.now();\n             const result = await Promise.race([\n               checker.check(),\n               this.timeout(5000),\n             ]);\n             checks[name] = {\n               ...result,\n               latency: Date.now() - start,\n             };\n\n             if (result.status === 'unhealthy') {\n               if (checker.critical) hasCriticalFailure = true;\n               else hasDegradation = true;\n             }\n           } catch (error) {\n             checks[name] = {\n               status: 'unhealthy',\n               message: error.message,\n               lastCheck: new Date().toISOString(),\n             };\n             if (checker.critical) hasCriticalFailure = true;\n           }\n         })\n       );\n\n       return {\n         status: hasCriticalFailure ? 'unhealthy' : hasDegradation ? 'degraded' : 'healthy',\n         timestamp: new Date().toISOString(),\n         version: this.version,\n         uptime: Date.now() - this.startTime,\n         checks,\n       };\n     }\n\n     async deep(): Promise<HealthCheckResult> {\n       // Same as readiness but with more detailed checks\n       return this.readiness();\n     }\n\n     private timeout(ms: number): Promise<never> {\n       return new Promise((_, reject) => \n         setTimeout(() => reject(new Error('Health check timeout')), ms)\n       );\n     }\n   }\n   ```\n\n2. Create common checkers:\n   ```typescript\n   // packages/health-check/src/checkers/mongodb.ts\n   import { Db } from 'mongodb';\n   import { HealthChecker, DependencyCheck } from '../index';\n\n   export function createMongoChecker(db: Db): HealthChecker {\n     return {\n       name: 'mongodb',\n       critical: true,\n       async check(): Promise<DependencyCheck> {\n         try {\n           await db.command({ ping: 1 });\n           return {\n             status: 'healthy',\n             lastCheck: new Date().toISOString(),\n           };\n         } catch (error) {\n           return {\n             status: 'unhealthy',\n             message: error.message,\n             lastCheck: new Date().toISOString(),\n           };\n         }\n       },\n     };\n   }\n\n   // packages/health-check/src/checkers/redis.ts\n   import { Redis } from 'ioredis';\n\n   export function createRedisChecker(redis: Redis): HealthChecker {\n     return {\n       name: 'redis',\n       critical: true,\n       async check(): Promise<DependencyCheck> {\n         try {\n           await redis.ping();\n           return {\n             status: 'healthy',\n             lastCheck: new Date().toISOString(),\n           };\n         } catch (error) {\n           return {\n             status: 'unhealthy',\n             message: error.message,\n             lastCheck: new Date().toISOString(),\n           };\n         }\n       },\n     };\n   }\n\n   // packages/health-check/src/checkers/kafka.ts\n   import { Kafka } from 'kafkajs';\n\n   export function createKafkaChecker(kafka: Kafka): HealthChecker {\n     return {\n       name: 'kafka',\n       critical: false,\n       async check(): Promise<DependencyCheck> {\n         try {\n           const admin = kafka.admin();\n           await admin.connect();\n           await admin.listTopics();\n           await admin.disconnect();\n           return {\n             status: 'healthy',\n             lastCheck: new Date().toISOString(),\n           };\n         } catch (error) {\n           return {\n             status: 'unhealthy',\n             message: error.message,\n             lastCheck: new Date().toISOString(),\n           };\n         }\n       },\n     };\n   }\n   ```\n\n3. Create Fastify plugin:\n   ```typescript\n   // packages/health-check/src/fastify-plugin.ts\n   import { FastifyPluginAsync } from 'fastify';\n   import { HealthCheckService } from './index';\n\n   declare module 'fastify' {\n     interface FastifyInstance {\n       healthCheck: HealthCheckService;\n     }\n   }\n\n   export const healthPlugin: FastifyPluginAsync<{ version: string }> = async (fastify, opts) => {\n     const healthCheck = new HealthCheckService(opts.version);\n     fastify.decorate('healthCheck', healthCheck);\n\n     fastify.get('/health/live', async () => {\n       return healthCheck.liveness();\n     });\n\n     fastify.get('/health/ready', async (request, reply) => {\n       const result = await healthCheck.readiness();\n       reply.code(result.status === 'healthy' ? 200 : result.status === 'degraded' ? 200 : 503);\n       return result;\n     });\n\n     fastify.get('/health/deep', async (request, reply) => {\n       const result = await healthCheck.deep();\n       reply.code(result.status === 'healthy' ? 200 : 503);\n       return result;\n     });\n   };\n   ```",
      "testing_instructions": {
        "unit_tests": [
          "Test health check aggregation",
          "Test timeout handling",
          "Test status calculation"
        ],
        "integration_tests": [
          "Test with real dependencies",
          "Test failure scenarios"
        ],
        "e2e_tests": []
      },
      "acceptance_criteria": [
        "Health check library works",
        "Checkers for all dependencies",
        "Fastify plugin works",
        "Timeout handling works"
      ],
      "files_to_create": [
        "packages/health-check/src/index.ts",
        "packages/health-check/src/checkers/mongodb.ts",
        "packages/health-check/src/checkers/redis.ts",
        "packages/health-check/src/checkers/kafka.ts",
        "packages/health-check/src/fastify-plugin.ts",
        "packages/health-check/package.json"
      ],
      "files_to_modify": [],
      "docker_requirements": {
        "services": [],
        "environment_variables": [],
        "volumes": [],
        "networks": []
      },
      "api_endpoints": [],
      "database_changes": {
        "collections": [],
        "indexes": [],
        "migrations": []
      },
      "status": "not_started",
      "estimated_hours": 4,
      "tags": ["health", "library", "shared"]
    },
    {
      "id": "HEALTH-002",
      "task_name": "Gateway Health Endpoints",
      "feature_details": "Implement health endpoints in the API Gateway.",
      "feature_dependency": ["HEALTH-001", "GATEWAY-001"],
      "ai_prompt": "Implement health endpoints in Gateway:\n\n1. Update services/gateway/src/health.ts:\n   ```typescript\n   import { FastifyPluginAsync } from 'fastify';\n   import { healthPlugin, createMongoChecker, createRedisChecker } from '@caas/health-check';\n   import { version } from '../package.json';\n\n   export const setupHealth: FastifyPluginAsync = async (fastify) => {\n     await fastify.register(healthPlugin, { version });\n\n     // Register dependency checkers\n     fastify.healthCheck.register(createMongoChecker(fastify.mongo.db));\n     fastify.healthCheck.register(createRedisChecker(fastify.redis));\n     \n     // Custom gateway-specific checks\n     fastify.healthCheck.register({\n       name: 'rate-limiter',\n       critical: false,\n       async check() {\n         try {\n           // Verify rate limiter is working\n           await fastify.redis.get('rate-limit:test');\n           return { status: 'healthy', lastCheck: new Date().toISOString() };\n         } catch (error) {\n           return { status: 'unhealthy', message: error.message, lastCheck: new Date().toISOString() };\n         }\n       },\n     });\n\n     // Downstream service checks\n     fastify.healthCheck.register({\n       name: 'auth-service',\n       critical: true,\n       async check() {\n         try {\n           const response = await fetch(`${process.env.AUTH_SERVICE_URL}/health/live`);\n           return {\n             status: response.ok ? 'healthy' : 'unhealthy',\n             lastCheck: new Date().toISOString(),\n           };\n         } catch (error) {\n           return { status: 'unhealthy', message: error.message, lastCheck: new Date().toISOString() };\n         }\n       },\n     });\n   };\n   ```\n\n2. Add Kubernetes probe configuration:\n   ```yaml\n   # In Kubernetes deployment\n   livenessProbe:\n     httpGet:\n       path: /health/live\n       port: 3000\n     initialDelaySeconds: 10\n     periodSeconds: 10\n     failureThreshold: 3\n\n   readinessProbe:\n     httpGet:\n       path: /health/ready\n       port: 3000\n     initialDelaySeconds: 5\n     periodSeconds: 5\n     failureThreshold: 3\n   ```\n\n3. Add graceful shutdown:\n   ```typescript\n   process.on('SIGTERM', async () => {\n     fastify.log.info('SIGTERM received, starting graceful shutdown');\n     \n     // Mark as not ready\n     fastify.healthCheck.setShuttingDown(true);\n     \n     // Wait for in-flight requests\n     await new Promise(resolve => setTimeout(resolve, 5000));\n     \n     await fastify.close();\n     process.exit(0);\n   });\n   ```",
      "testing_instructions": {
        "unit_tests": [
          "Test health endpoints return correct status"
        ],
        "integration_tests": [
          "Test with dependencies down",
          "Test graceful shutdown"
        ],
        "e2e_tests": []
      },
      "acceptance_criteria": [
        "Health endpoints work",
        "Kubernetes probes configured",
        "Graceful shutdown works",
        "Downstream checks work"
      ],
      "files_to_create": [
        "services/gateway/src/health.ts"
      ],
      "files_to_modify": [
        "services/gateway/src/index.ts"
      ],
      "docker_requirements": {
        "services": [],
        "environment_variables": [],
        "volumes": [],
        "networks": []
      },
      "api_endpoints": [
        {
          "method": "GET",
          "path": "/health/live",
          "description": "Liveness probe"
        },
        {
          "method": "GET",
          "path": "/health/ready",
          "description": "Readiness probe"
        },
        {
          "method": "GET",
          "path": "/health/deep",
          "description": "Deep health check"
        }
      ],
      "database_changes": {
        "collections": [],
        "indexes": [],
        "migrations": []
      },
      "status": "not_started",
      "estimated_hours": 3,
      "tags": ["health", "gateway", "kubernetes"]
    },
    {
      "id": "HEALTH-003",
      "task_name": "Health Aggregator Service",
      "feature_details": "Create central health aggregation service.",
      "feature_dependency": ["HEALTH-001"],
      "ai_prompt": "Create health aggregator service:\n\n1. Create services/health-aggregator/src/index.ts:\n   ```typescript\n   import Fastify from 'fastify';\n   import { config } from './config';\n\n   interface ServiceHealth {\n     name: string;\n     url: string;\n     critical: boolean;\n   }\n\n   const services: ServiceHealth[] = [\n     { name: 'gateway', url: 'http://gateway:3000', critical: true },\n     { name: 'auth', url: 'http://auth-service:3001', critical: true },\n     { name: 'socket', url: 'http://socket-service:3002', critical: true },\n     { name: 'messaging', url: 'http://messaging-service:3003', critical: true },\n     { name: 'media', url: 'http://media-service:3004', critical: false },\n     { name: 'analytics', url: 'http://analytics-service:3006', critical: false },\n   ];\n\n   const app = Fastify({ logger: true });\n\n   app.get('/status', async () => {\n     const results = await Promise.all(\n       services.map(async (service) => {\n         try {\n           const response = await fetch(`${service.url}/health/ready`, {\n             signal: AbortSignal.timeout(5000),\n           });\n           const data = await response.json();\n           return {\n             name: service.name,\n             status: data.status,\n             latency: response.headers.get('x-response-time'),\n             checks: data.checks,\n           };\n         } catch (error) {\n           return {\n             name: service.name,\n             status: 'unhealthy',\n             error: error.message,\n           };\n         }\n       })\n     );\n\n     const overallStatus = results.every(r => r.status === 'healthy')\n       ? 'operational'\n       : results.some(r => r.status === 'unhealthy' && services.find(s => s.name === r.name)?.critical)\n       ? 'outage'\n       : 'degraded';\n\n     return {\n       status: overallStatus,\n       timestamp: new Date().toISOString(),\n       services: results,\n     };\n   });\n\n   app.get('/status/history', async () => {\n     // Get last 24 hours of status history from MongoDB\n     const history = await db.collection('status_history')\n       .find({ timestamp: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) }})\n       .sort({ timestamp: -1 })\n       .toArray();\n     return history;\n   });\n\n   // Background job to record status\n   setInterval(async () => {\n     const status = await getAggregatedStatus();\n     await db.collection('status_history').insertOne({\n       ...status,\n       recordedAt: new Date(),\n     });\n   }, 60000); // Every minute\n\n   app.listen({ port: config.port, host: '0.0.0.0' });\n   ```\n\n2. Create uptime calculation:\n   ```typescript\n   async function calculateUptime(days: number = 30) {\n     const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);\n     \n     const records = await db.collection('status_history')\n       .find({ recordedAt: { $gte: startDate }})\n       .toArray();\n     \n     const total = records.length;\n     const healthy = records.filter(r => r.status === 'operational').length;\n     \n     return {\n       uptimePercentage: (healthy / total * 100).toFixed(3),\n       totalChecks: total,\n       healthyChecks: healthy,\n       period: `${days} days`,\n     };\n   }\n   ```\n\n3. Docker setup:\n   ```dockerfile\n   FROM node:20-alpine\n   WORKDIR /app\n   COPY package*.json ./\n   RUN npm ci --only=production\n   COPY dist/ ./dist/\n   EXPOSE 3010\n   CMD [\"node\", \"dist/index.js\"]\n   ```",
      "testing_instructions": {
        "unit_tests": [
          "Test status aggregation",
          "Test uptime calculation"
        ],
        "integration_tests": [
          "Test with services up/down",
          "Test history recording"
        ],
        "e2e_tests": []
      },
      "acceptance_criteria": [
        "Aggregates all service health",
        "Records history",
        "Calculates uptime",
        "Returns correct overall status"
      ],
      "files_to_create": [
        "services/health-aggregator/src/index.ts",
        "services/health-aggregator/src/config.ts",
        "services/health-aggregator/package.json",
        "services/health-aggregator/Dockerfile"
      ],
      "files_to_modify": [
        "docker-compose.yml"
      ],
      "docker_requirements": {
        "services": ["health-aggregator"],
        "environment_variables": [
          "MONGODB_URI",
          "PORT"
        ],
        "volumes": [],
        "networks": ["caas-network"]
      },
      "api_endpoints": [
        {
          "method": "GET",
          "path": "/status",
          "description": "Get aggregated status"
        },
        {
          "method": "GET",
          "path": "/status/history",
          "description": "Get status history"
        }
      ],
      "database_changes": {
        "collections": [
          {
            "name": "status_history",
            "description": "Historical status records"
          }
        ],
        "indexes": [
          {
            "collection": "status_history",
            "keys": { "recordedAt": -1 },
            "options": { "name": "status_history_time", "expireAfterSeconds": 2592000 }
          }
        ],
        "migrations": []
      },
      "status": "not_started",
      "estimated_hours": 5,
      "tags": ["health", "aggregator", "status"]
    }
  ]
}
