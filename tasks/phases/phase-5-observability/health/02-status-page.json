{
  "task_group": "status-page",
  "description": "Public status page and incident management",
  "priority": "medium",
  "estimated_hours": 12,
  "phase": 5,
  "feature_area": "health",
  "tasks": [
    {
      "id": "HEALTH-004",
      "task_name": "Status Page UI",
      "feature_details": "Create public status page for service status communication.",
      "feature_dependency": ["HEALTH-003"],
      "ai_prompt": "Create status page UI:\n\n1. Create apps/status-page/src/pages/index.tsx:\n   ```tsx\n   import { useQuery } from '@tanstack/react-query';\n   import { StatusHeader } from '../components/StatusHeader';\n   import { ServiceList } from '../components/ServiceList';\n   import { IncidentList } from '../components/IncidentList';\n   import { UptimeChart } from '../components/UptimeChart';\n\n   export default function StatusPage() {\n     const { data: status, isLoading } = useQuery({\n       queryKey: ['status'],\n       queryFn: () => fetch('/api/status').then(r => r.json()),\n       refetchInterval: 30000, // 30 seconds\n     });\n\n     const { data: incidents } = useQuery({\n       queryKey: ['incidents'],\n       queryFn: () => fetch('/api/incidents').then(r => r.json()),\n     });\n\n     return (\n       <div className=\"status-page\">\n         <StatusHeader\n           status={status?.status}\n           loading={isLoading}\n         />\n\n         <section className=\"services-section\">\n           <h2>Services</h2>\n           <ServiceList\n             services={status?.services}\n             loading={isLoading}\n           />\n         </section>\n\n         <section className=\"uptime-section\">\n           <h2>Uptime (Last 90 Days)</h2>\n           <UptimeChart />\n         </section>\n\n         <section className=\"incidents-section\">\n           <h2>Recent Incidents</h2>\n           <IncidentList incidents={incidents} />\n         </section>\n\n         <footer>\n           <p>Last updated: {status?.timestamp}</p>\n         </footer>\n       </div>\n     );\n   }\n   ```\n\n2. Create apps/status-page/src/components/StatusHeader.tsx:\n   ```tsx\n   interface Props {\n     status?: 'operational' | 'degraded' | 'outage';\n     loading: boolean;\n   }\n\n   const statusConfig = {\n     operational: {\n       icon: '✓',\n       text: 'All Systems Operational',\n       color: 'green',\n     },\n     degraded: {\n       icon: '!',\n       text: 'Partial System Outage',\n       color: 'yellow',\n     },\n     outage: {\n       icon: '✕',\n       text: 'Major System Outage',\n       color: 'red',\n     },\n   };\n\n   export function StatusHeader({ status = 'operational', loading }: Props) {\n     const config = statusConfig[status];\n\n     return (\n       <header className={`status-header status-${config.color}`}>\n         {loading ? (\n           <div className=\"loading\">Checking status...</div>\n         ) : (\n           <>\n             <span className=\"status-icon\">{config.icon}</span>\n             <h1>{config.text}</h1>\n           </>\n         )}\n       </header>\n     );\n   }\n   ```\n\n3. Create apps/status-page/src/components/ServiceList.tsx:\n   ```tsx\n   interface Service {\n     name: string;\n     status: 'healthy' | 'degraded' | 'unhealthy';\n     latency?: number;\n   }\n\n   export function ServiceList({ services, loading }: { services?: Service[]; loading: boolean }) {\n     if (loading) return <ServiceListSkeleton />;\n\n     return (\n       <ul className=\"service-list\">\n         {services?.map((service) => (\n           <li key={service.name} className=\"service-item\">\n             <span className={`status-dot status-${service.status}`} />\n             <span className=\"service-name\">{formatServiceName(service.name)}</span>\n             <span className=\"service-status\">{service.status}</span>\n             {service.latency && (\n               <span className=\"service-latency\">{service.latency}ms</span>\n             )}\n           </li>\n         ))}\n       </ul>\n     );\n   }\n\n   function formatServiceName(name: string): string {\n     const names: Record<string, string> = {\n       gateway: 'API Gateway',\n       auth: 'Authentication',\n       socket: 'Real-time Messaging',\n       messaging: 'Message Storage',\n       media: 'Media Processing',\n       analytics: 'Analytics',\n     };\n     return names[name] || name;\n   }\n   ```\n\n4. Add styles:\n   ```css\n   .status-page {\n     max-width: 800px;\n     margin: 0 auto;\n     padding: 24px;\n     font-family: system-ui, sans-serif;\n   }\n\n   .status-header {\n     padding: 32px;\n     border-radius: 8px;\n     text-align: center;\n     margin-bottom: 32px;\n   }\n\n   .status-green { background: #d4edda; color: #155724; }\n   .status-yellow { background: #fff3cd; color: #856404; }\n   .status-red { background: #f8d7da; color: #721c24; }\n\n   .service-list {\n     list-style: none;\n     padding: 0;\n   }\n\n   .service-item {\n     display: flex;\n     align-items: center;\n     padding: 16px;\n     border-bottom: 1px solid #eee;\n   }\n\n   .status-dot {\n     width: 12px;\n     height: 12px;\n     border-radius: 50%;\n     margin-right: 12px;\n   }\n\n   .status-dot.status-healthy { background: #28a745; }\n   .status-dot.status-degraded { background: #ffc107; }\n   .status-dot.status-unhealthy { background: #dc3545; }\n   ```",
      "testing_instructions": {
        "unit_tests": [
          "Test component rendering",
          "Test status display"
        ],
        "integration_tests": [
          "Test data fetching",
          "Test auto-refresh"
        ],
        "e2e_tests": [
          "Test full page load"
        ]
      },
      "acceptance_criteria": [
        "Status page renders correctly",
        "Auto-refreshes every 30s",
        "Shows all services",
        "Responsive design"
      ],
      "files_to_create": [
        "apps/status-page/src/pages/index.tsx",
        "apps/status-page/src/components/StatusHeader.tsx",
        "apps/status-page/src/components/ServiceList.tsx",
        "apps/status-page/src/components/UptimeChart.tsx",
        "apps/status-page/src/styles/status.css",
        "apps/status-page/package.json"
      ],
      "files_to_modify": [],
      "docker_requirements": {
        "services": ["status-page"],
        "environment_variables": [
          "API_URL"
        ],
        "volumes": [],
        "networks": ["caas-network"]
      },
      "api_endpoints": [],
      "database_changes": {
        "collections": [],
        "indexes": [],
        "migrations": []
      },
      "status": "not_started",
      "estimated_hours": 4,
      "tags": ["status-page", "ui", "public"]
    },
    {
      "id": "HEALTH-005",
      "task_name": "Incident Management",
      "feature_details": "Create incident management system for status updates.",
      "feature_dependency": ["HEALTH-003"],
      "ai_prompt": "Create incident management system:\n\n1. Create services/health-aggregator/src/incidents.ts:\n   ```typescript\n   import { Db, ObjectId } from 'mongodb';\n\n   export interface Incident {\n     _id: ObjectId;\n     title: string;\n     status: 'investigating' | 'identified' | 'monitoring' | 'resolved';\n     impact: 'none' | 'minor' | 'major' | 'critical';\n     affectedServices: string[];\n     updates: IncidentUpdate[];\n     createdAt: Date;\n     resolvedAt?: Date;\n   }\n\n   export interface IncidentUpdate {\n     id: string;\n     status: Incident['status'];\n     message: string;\n     createdAt: Date;\n     createdBy: string;\n   }\n\n   export class IncidentService {\n     constructor(private db: Db) {}\n\n     async create(data: Omit<Incident, '_id' | 'updates' | 'createdAt'>): Promise<Incident> {\n       const incident: Omit<Incident, '_id'> = {\n         ...data,\n         updates: [{\n           id: crypto.randomUUID(),\n           status: data.status,\n           message: `Incident created: ${data.title}`,\n           createdAt: new Date(),\n           createdBy: 'system',\n         }],\n         createdAt: new Date(),\n       };\n\n       const result = await this.db.collection<Incident>('incidents').insertOne(incident as Incident);\n       return { ...incident, _id: result.insertedId } as Incident;\n     }\n\n     async addUpdate(\n       incidentId: string,\n       update: Omit<IncidentUpdate, 'id' | 'createdAt'>\n     ): Promise<void> {\n       const updateDoc: IncidentUpdate = {\n         ...update,\n         id: crypto.randomUUID(),\n         createdAt: new Date(),\n       };\n\n       await this.db.collection<Incident>('incidents').updateOne(\n         { _id: new ObjectId(incidentId) },\n         {\n           $push: { updates: updateDoc },\n           $set: {\n             status: update.status,\n             ...(update.status === 'resolved' ? { resolvedAt: new Date() } : {}),\n           },\n         }\n       );\n     }\n\n     async getActive(): Promise<Incident[]> {\n       return this.db.collection<Incident>('incidents')\n         .find({ status: { $ne: 'resolved' }})\n         .sort({ createdAt: -1 })\n         .toArray();\n     }\n\n     async getRecent(limit: number = 10): Promise<Incident[]> {\n       return this.db.collection<Incident>('incidents')\n         .find()\n         .sort({ createdAt: -1 })\n         .limit(limit)\n         .toArray();\n     }\n\n     async getById(id: string): Promise<Incident | null> {\n       return this.db.collection<Incident>('incidents')\n         .findOne({ _id: new ObjectId(id) });\n     }\n   }\n   ```\n\n2. Create incident API routes:\n   ```typescript\n   fastify.get('/incidents', async () => {\n     return incidentService.getRecent();\n   });\n\n   fastify.get('/incidents/active', async () => {\n     return incidentService.getActive();\n   });\n\n   fastify.get('/incidents/:id', async (request) => {\n     const { id } = request.params as { id: string };\n     return incidentService.getById(id);\n   });\n\n   // Admin routes (protected)\n   fastify.post('/admin/incidents', {\n     preHandler: [fastify.authenticate, fastify.requireAdmin],\n     handler: async (request) => {\n       return incidentService.create(request.body);\n     },\n   });\n\n   fastify.post('/admin/incidents/:id/updates', {\n     preHandler: [fastify.authenticate, fastify.requireAdmin],\n     handler: async (request) => {\n       const { id } = request.params as { id: string };\n       const update = {\n         ...request.body,\n         createdBy: request.user.email,\n       };\n       await incidentService.addUpdate(id, update);\n       return { success: true };\n     },\n   });\n   ```\n\n3. Create notification integration:\n   ```typescript\n   async function notifyIncidentUpdate(incident: Incident, update: IncidentUpdate) {\n     // Email subscribers\n     const subscribers = await db.collection('status_subscribers').find().toArray();\n     \n     await Promise.all(\n       subscribers.map(sub => \n         emailService.send({\n           to: sub.email,\n           subject: `[${incident.status.toUpperCase()}] ${incident.title}`,\n           html: renderIncidentEmail(incident, update),\n         })\n       )\n     );\n\n     // Slack webhook\n     if (process.env.SLACK_WEBHOOK_URL) {\n       await fetch(process.env.SLACK_WEBHOOK_URL, {\n         method: 'POST',\n         headers: { 'Content-Type': 'application/json' },\n         body: JSON.stringify({\n           text: `*${incident.status.toUpperCase()}*: ${incident.title}\\n${update.message}`,\n         }),\n       });\n     }\n   }\n   ```",
      "testing_instructions": {
        "unit_tests": [
          "Test incident CRUD",
          "Test status transitions"
        ],
        "integration_tests": [
          "Test notification delivery",
          "Test API endpoints"
        ],
        "e2e_tests": []
      },
      "acceptance_criteria": [
        "Incidents can be created",
        "Updates can be added",
        "Notifications sent",
        "API endpoints work"
      ],
      "files_to_create": [
        "services/health-aggregator/src/incidents.ts",
        "services/health-aggregator/src/routes/incidents.ts",
        "services/health-aggregator/src/notifications.ts"
      ],
      "files_to_modify": [
        "services/health-aggregator/src/index.ts"
      ],
      "docker_requirements": {
        "services": [],
        "environment_variables": [
          "SLACK_WEBHOOK_URL"
        ],
        "volumes": [],
        "networks": []
      },
      "api_endpoints": [
        {
          "method": "GET",
          "path": "/incidents",
          "description": "Get recent incidents"
        },
        {
          "method": "GET",
          "path": "/incidents/active",
          "description": "Get active incidents"
        },
        {
          "method": "POST",
          "path": "/admin/incidents",
          "description": "Create new incident"
        },
        {
          "method": "POST",
          "path": "/admin/incidents/:id/updates",
          "description": "Add incident update"
        }
      ],
      "database_changes": {
        "collections": [
          {
            "name": "incidents",
            "description": "Incident records"
          },
          {
            "name": "status_subscribers",
            "description": "Status update subscribers"
          }
        ],
        "indexes": [
          {
            "collection": "incidents",
            "keys": { "status": 1, "createdAt": -1 },
            "options": { "name": "incidents_active" }
          }
        ],
        "migrations": []
      },
      "status": "not_started",
      "estimated_hours": 4,
      "tags": ["incidents", "status", "notifications"]
    },
    {
      "id": "HEALTH-006",
      "task_name": "Uptime Monitoring",
      "feature_details": "Create uptime tracking and reporting.",
      "feature_dependency": ["HEALTH-003"],
      "ai_prompt": "Create uptime monitoring:\n\n1. Create services/health-aggregator/src/uptime.ts:\n   ```typescript\n   import { Db } from 'mongodb';\n\n   interface UptimeRecord {\n     date: Date;\n     service: string;\n     totalChecks: number;\n     successfulChecks: number;\n     failedChecks: number;\n     avgLatency: number;\n     p99Latency: number;\n   }\n\n   export class UptimeService {\n     constructor(private db: Db) {}\n\n     async recordCheck(service: string, success: boolean, latency: number) {\n       const today = new Date();\n       today.setHours(0, 0, 0, 0);\n\n       await this.db.collection('uptime_daily').updateOne(\n         { date: today, service },\n         {\n           $inc: {\n             totalChecks: 1,\n             successfulChecks: success ? 1 : 0,\n             failedChecks: success ? 0 : 1,\n           },\n           $push: {\n             latencies: { $each: [latency], $slice: -1440 }, // Keep last 1440 (24h of minute checks)\n           },\n         },\n         { upsert: true }\n       );\n     }\n\n     async getUptime(service: string, days: number = 90): Promise<number> {\n       const startDate = new Date();\n       startDate.setDate(startDate.getDate() - days);\n       startDate.setHours(0, 0, 0, 0);\n\n       const result = await this.db.collection('uptime_daily').aggregate([\n         { $match: { service, date: { $gte: startDate }}},\n         { $group: {\n           _id: null,\n           totalChecks: { $sum: '$totalChecks' },\n           successfulChecks: { $sum: '$successfulChecks' },\n         }},\n       ]).toArray();\n\n       if (!result.length) return 100;\n       return (result[0].successfulChecks / result[0].totalChecks) * 100;\n     }\n\n     async getDailyUptime(service: string, days: number = 90): Promise<{ date: string; uptime: number }[]> {\n       const startDate = new Date();\n       startDate.setDate(startDate.getDate() - days);\n       startDate.setHours(0, 0, 0, 0);\n\n       const records = await this.db.collection('uptime_daily')\n         .find({ service, date: { $gte: startDate }})\n         .sort({ date: 1 })\n         .toArray();\n\n       return records.map(r => ({\n         date: r.date.toISOString().split('T')[0],\n         uptime: (r.successfulChecks / r.totalChecks) * 100,\n       }));\n     }\n\n     async getAllServicesUptime(days: number = 90): Promise<Record<string, number>> {\n       const services = ['gateway', 'auth', 'socket', 'messaging', 'media', 'analytics'];\n       const uptimes: Record<string, number> = {};\n\n       await Promise.all(\n         services.map(async (service) => {\n           uptimes[service] = await this.getUptime(service, days);\n         })\n       );\n\n       return uptimes;\n     }\n   }\n   ```\n\n2. Create uptime chart component:\n   ```tsx\n   // apps/status-page/src/components/UptimeChart.tsx\n   import { useQuery } from '@tanstack/react-query';\n\n   export function UptimeChart() {\n     const { data: uptimeData } = useQuery({\n       queryKey: ['uptime'],\n       queryFn: () => fetch('/api/uptime?days=90').then(r => r.json()),\n     });\n\n     return (\n       <div className=\"uptime-chart\">\n         <div className=\"uptime-summary\">\n           <span className=\"uptime-value\">{uptimeData?.overall?.toFixed(3)}%</span>\n           <span className=\"uptime-label\">Overall Uptime</span>\n         </div>\n\n         <div className=\"uptime-bars\">\n           {uptimeData?.daily?.map((day: { date: string; uptime: number }) => (\n             <div\n               key={day.date}\n               className={`uptime-bar ${getUptimeClass(day.uptime)}`}\n               title={`${day.date}: ${day.uptime.toFixed(2)}%`}\n             />\n           ))}\n         </div>\n\n         <div className=\"uptime-legend\">\n           <span>90 days ago</span>\n           <span>Today</span>\n         </div>\n       </div>\n     );\n   }\n\n   function getUptimeClass(uptime: number): string {\n     if (uptime >= 99.9) return 'uptime-green';\n     if (uptime >= 99) return 'uptime-yellow';\n     return 'uptime-red';\n   }\n   ```\n\n3. Add uptime API routes:\n   ```typescript\n   fastify.get('/uptime', async (request) => {\n     const { days = 90 } = request.query as { days?: number };\n     \n     const [overall, daily, byService] = await Promise.all([\n       uptimeService.getUptime('overall', days),\n       uptimeService.getDailyUptime('overall', days),\n       uptimeService.getAllServicesUptime(days),\n     ]);\n\n     return { overall, daily, byService };\n   });\n\n   fastify.get('/uptime/:service', async (request) => {\n     const { service } = request.params as { service: string };\n     const { days = 90 } = request.query as { days?: number };\n     \n     const [uptime, daily] = await Promise.all([\n       uptimeService.getUptime(service, days),\n       uptimeService.getDailyUptime(service, days),\n     ]);\n\n     return { uptime, daily };\n   });\n   ```",
      "testing_instructions": {
        "unit_tests": [
          "Test uptime calculation",
          "Test daily aggregation"
        ],
        "integration_tests": [
          "Test with historical data",
          "Test API endpoints"
        ],
        "e2e_tests": []
      },
      "acceptance_criteria": [
        "Uptime calculated correctly",
        "Daily records stored",
        "90-day history available",
        "Chart renders correctly"
      ],
      "files_to_create": [
        "services/health-aggregator/src/uptime.ts",
        "apps/status-page/src/components/UptimeChart.tsx"
      ],
      "files_to_modify": [
        "services/health-aggregator/src/routes/index.ts"
      ],
      "docker_requirements": {
        "services": [],
        "environment_variables": [],
        "volumes": [],
        "networks": []
      },
      "api_endpoints": [
        {
          "method": "GET",
          "path": "/uptime",
          "description": "Get overall uptime"
        },
        {
          "method": "GET",
          "path": "/uptime/:service",
          "description": "Get service-specific uptime"
        }
      ],
      "database_changes": {
        "collections": [
          {
            "name": "uptime_daily",
            "description": "Daily uptime records"
          }
        ],
        "indexes": [
          {
            "collection": "uptime_daily",
            "keys": { "service": 1, "date": -1 },
            "options": { "name": "uptime_daily_service" }
          }
        ],
        "migrations": []
      },
      "status": "not_started",
      "estimated_hours": 4,
      "tags": ["uptime", "monitoring", "reporting"]
    }
  ]
}
