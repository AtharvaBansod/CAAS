/**
 * TOTP Service
 * Phase 2 - Authentication - Task AUTH-009
 * 
 * Time-based One-Time Password implementation
 */

import { createHmac, randomBytes } from 'crypto';
import * as OTPAuth from 'otpauth';
import { TOTPSetup } from '../types';

export interface TOTPConfig {
  issuer: string;
  algorithm: string;
  digits: number;
  period: number;
  window: number;
}

export const defaultTOTPConfig: TOTPConfig = {
  issuer: process.env.TOTP_ISSUER || 'CAAS',
  algorithm: process.env.TOTP_ALGORITHM || 'SHA1',
  digits: parseInt(process.env.TOTP_DIGITS || '6', 10),
  period: parseInt(process.env.TOTP_PERIOD || '30', 10),
  window: parseInt(process.env.TOTP_WINDOW || '1', 10),
};

export class TOTPService {
  constructor(private config: TOTPConfig = defaultTOTPConfig) {}

  /**
   * Generate TOTP secret and setup data
   */
  generateSecret(userEmail: string): Omit<TOTPSetup, 'backup_codes'> {
    // Generate random secret (base32 encoded)
    const secret = this.generateBase32Secret();

    // Create TOTP instance
    const totp = new OTPAuth.TOTP({
      issuer: this.config.issuer,
      label: userEmail,
      algorithm: this.config.algorithm,
      digits: this.config.digits,
      period: this.config.period,
      secret: secret,
    });

    // Generate URI for QR code
    const uri = totp.toString();

    return {
      secret,
      uri,
      qr_code: '', // Will be generated by QR generator
    };
  }

  /**
   * Verify TOTP token
   */
  verifyToken(secret: string, token: string): boolean {
    try {
      const totp = new OTPAuth.TOTP({
        issuer: this.config.issuer,
        algorithm: this.config.algorithm,
        digits: this.config.digits,
        period: this.config.period,
        secret: secret,
      });

      // Validate token with time window
      const delta = totp.validate({
        token,
        window: this.config.window,
      });

      // delta is null if invalid, or the time step difference if valid
      return delta !== null;
    } catch (error) {
      console.error('TOTP verification error:', error);
      return false;
    }
  }

  /**
   * Generate current TOTP token (for testing)
   */
  generateToken(secret: string): string {
    const totp = new OTPAuth.TOTP({
      issuer: this.config.issuer,
      algorithm: this.config.algorithm,
      digits: this.config.digits,
      period: this.config.period,
      secret: secret,
    });

    return totp.generate();
  }

  /**
   * Get time remaining until next token
   */
  getTimeRemaining(): number {
    const now = Math.floor(Date.now() / 1000);
    const timeStep = now % this.config.period;
    return this.config.period - timeStep;
  }

  /**
   * Generate base32 secret
   */
  private generateBase32Secret(length: number = 32): string {
    const buffer = randomBytes(length);
    return this.base32Encode(buffer);
  }

  /**
   * Base32 encode
   */
  private base32Encode(buffer: Buffer): string {
    const base32Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    let bits = 0;
    let value = 0;
    let output = '';

    for (let i = 0; i < buffer.length; i++) {
      value = (value << 8) | buffer[i];
      bits += 8;

      while (bits >= 5) {
        output += base32Chars[(value >>> (bits - 5)) & 31];
        bits -= 5;
      }
    }

    if (bits > 0) {
      output += base32Chars[(value << (5 - bits)) & 31];
    }

    return output;
  }

  /**
   * Validate secret format
   */
  isValidSecret(secret: string): boolean {
    // Base32 characters only
    return /^[A-Z2-7]+=*$/.test(secret);
  }
}
