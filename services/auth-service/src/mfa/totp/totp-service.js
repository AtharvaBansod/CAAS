"use strict";
/**
 * TOTP Service
 * Phase 2 - Authentication - Task AUTH-009
 *
 * Time-based One-Time Password implementation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TOTPService = exports.defaultTOTPConfig = void 0;
const crypto_1 = require("crypto");
const OTPAuth = __importStar(require("otpauth"));
exports.defaultTOTPConfig = {
    issuer: process.env.TOTP_ISSUER || 'CAAS',
    algorithm: process.env.TOTP_ALGORITHM || 'SHA1',
    digits: parseInt(process.env.TOTP_DIGITS || '6', 10),
    period: parseInt(process.env.TOTP_PERIOD || '30', 10),
    window: parseInt(process.env.TOTP_WINDOW || '1', 10),
};
class TOTPService {
    config;
    constructor(config = exports.defaultTOTPConfig) {
        this.config = config;
    }
    /**
     * Generate TOTP secret and setup data
     */
    generateSecret(userEmail) {
        // Generate random secret (base32 encoded)
        const secret = this.generateBase32Secret();
        // Create TOTP instance
        const totp = new OTPAuth.TOTP({
            issuer: this.config.issuer,
            label: userEmail,
            algorithm: this.config.algorithm,
            digits: this.config.digits,
            period: this.config.period,
            secret: secret,
        });
        // Generate URI for QR code
        const uri = totp.toString();
        return {
            secret,
            uri,
            qr_code: '', // Will be generated by QR generator
        };
    }
    /**
     * Verify TOTP token
     */
    verifyToken(secret, token) {
        try {
            const totp = new OTPAuth.TOTP({
                issuer: this.config.issuer,
                algorithm: this.config.algorithm,
                digits: this.config.digits,
                period: this.config.period,
                secret: secret,
            });
            // Validate token with time window
            const delta = totp.validate({
                token,
                window: this.config.window,
            });
            // delta is null if invalid, or the time step difference if valid
            return delta !== null;
        }
        catch (error) {
            console.error('TOTP verification error:', error);
            return false;
        }
    }
    /**
     * Generate current TOTP token (for testing)
     */
    generateToken(secret) {
        const totp = new OTPAuth.TOTP({
            issuer: this.config.issuer,
            algorithm: this.config.algorithm,
            digits: this.config.digits,
            period: this.config.period,
            secret: secret,
        });
        return totp.generate();
    }
    /**
     * Get time remaining until next token
     */
    getTimeRemaining() {
        const now = Math.floor(Date.now() / 1000);
        const timeStep = now % this.config.period;
        return this.config.period - timeStep;
    }
    /**
     * Generate base32 secret
     */
    generateBase32Secret(length = 32) {
        const buffer = (0, crypto_1.randomBytes)(length);
        return this.base32Encode(buffer);
    }
    /**
     * Base32 encode
     */
    base32Encode(buffer) {
        const base32Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
        let bits = 0;
        let value = 0;
        let output = '';
        for (let i = 0; i < buffer.length; i++) {
            value = (value << 8) | buffer[i];
            bits += 8;
            while (bits >= 5) {
                output += base32Chars[(value >>> (bits - 5)) & 31];
                bits -= 5;
            }
        }
        if (bits > 0) {
            output += base32Chars[(value << (5 - bits)) & 31];
        }
        return output;
    }
    /**
     * Validate secret format
     */
    isValidSecret(secret) {
        // Base32 characters only
        return /^[A-Z2-7]+=*$/.test(secret);
    }
}
exports.TOTPService = TOTPService;
//# sourceMappingURL=totp-service.js.map
