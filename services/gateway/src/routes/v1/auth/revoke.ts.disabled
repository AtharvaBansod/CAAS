/**
 * Token Revocation Routes
 * Phase 2 - Authentication - Task AUTH-004
 * 
 * Implements comprehensive token revocation with Kafka event publishing
 */

import { FastifyPluginAsync } from 'fastify';
import { z } from 'zod';
import { RevocationReason } from '../../../types/auth';

const revokeRoutes: FastifyPluginAsync = async (fastify) => {
  /**
   * POST /v1/auth/revoke
   * Revoke current token
   */
  fastify.post(
    '/revoke',
    {
      schema: {
        description: 'Revoke current access token',
        tags: ['Authentication'],
        security: [{ bearerAuth: [] }],
        response: {
          200: z.object({
            success: z.boolean(),
            message: z.string(),
          }),
        },
      },
      preHandler: fastify.auth([fastify.verifyJWT]),
    },
    async (request, reply) => {
      const tokenId = request.user.jti;
      const userId = request.user.sub;

      if (!tokenId) {
        return reply.code(401).send({
          error: 'Unauthorized',
          message: 'Valid token required',
        });
      }

      // Revoke current token
      const revocationService = fastify.authServices.getRevocationService();
      await revocationService.revokeToken(tokenId, RevocationReason.LOGOUT);

      fastify.log.info({ userId, tokenId }, 'Token revoked by user');

      return {
        success: true,
        message: 'Token revoked successfully',
      };
    }
  );

  /**
   * POST /v1/auth/revoke-all
   * Revoke all user tokens
   */
  fastify.post(
    '/revoke-all',
    {
      schema: {
        description: 'Revoke all user tokens (requires password confirmation)',
        tags: ['Authentication'],
        security: [{ bearerAuth: [] }],
        body: z.object({
          password: z.string().min(1),
        }),
        response: {
          200: z.object({
            success: z.boolean(),
            message: z.string(),
            revoked_count: z.number(),
          }),
        },
      },
      preHandler: fastify.auth([fastify.verifyJWT]),
    },
    async (request, reply) => {
      const userId = request.user.sub;
      const { password } = request.body as { password: string };

      // TODO: Verify password against user database
      // For now, we'll skip password verification
      // In production, integrate with user service to verify password
      
      // Revoke all user tokens
      const revocationService = fastify.authServices.getRevocationService();
      const count = await revocationService.revokeUserTokens(
        userId,
        RevocationReason.ADMIN_ACTION
      );

      fastify.log.warn({ userId, count }, 'All user tokens revoked');

      return {
        success: true,
        message: 'All tokens revoked successfully',
        revoked_count: count,
      };
    }
  );

  /**
   * DELETE /v1/auth/sessions/:id
   * Terminate specific session (moved to /v1/sessions/:id)
   * This endpoint is kept for backward compatibility
   */
  fastify.delete(
    '/sessions/:id',
    {
      schema: {
        description: 'Terminate specific session (deprecated - use /v1/sessions/:id)',
        tags: ['Authentication'],
        security: [{ bearerAuth: [] }],
        params: z.object({
          id: z.string(),
        }),
        response: {
          200: z.object({
            success: z.boolean(),
            message: z.string(),
          }),
        },
      },
      preHandler: fastify.auth([fastify.verifyJWT]),
    },
    async (request, reply) => {
      const userId = request.user.sub;
      const { id: sessionId } = request.params as { id: string };

      // Verify session belongs to user and terminate
      const sessionService = fastify.authServices.getSessionService();
      const session = await sessionService.getSession(sessionId);

      if (!session || session.user_id !== userId) {
        return reply.code(404).send({
          success: false,
          message: 'Session not found',
        });
      }

      await sessionService.terminateSession(sessionId);

      fastify.log.info({ userId, sessionId }, 'Session terminated via auth route');

      return {
        success: true,
        message: 'Session terminated successfully',
      };
    }
  );
};

export default revokeRoutes;
